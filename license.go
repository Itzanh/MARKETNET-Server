package main

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io/ioutil"
	"math"
	"net/http"
	"os"

	"github.com/google/uuid"
)

const (
	CHANCE_URL   = "https://license.marketneterp.io:12278/chance"
	ACTIVATE_URL = "https://license.marketneterp.io:12278/activate"
)

// The maximum limit of concurrent connections limited by the adquired license.
var licenseMaxConnections int16

// Attempt product activation by license code. If the activation fails, the server will shut down.
// This function will be called in a new thread when the server is started.
func activate() {
	// The license code must be a valid UUID
	_, err := uuid.Parse(settings.Server.Activation.LicenseCode)
	if err != nil {
		fmt.Println("The license code in the config file is not a valid UUID.")
		fmt.Println("The application could not be activated by license and will shut down")
		os.Exit(2)
	}

	// If both the chance and the secret is null, the product can't be activated
	if settings.Server.Activation.Chance == nil && (settings.Server.Activation.Secret == nil || settings.Server.Activation.InstallId == nil) {
		fmt.Println("There is no chance or secret in the config file")
		fmt.Println("The application could not be activated by license and will shut down")
		os.Exit(2)
	}

	// If there is a chance, activate the license of the product.
	if settings.Server.Activation.Chance != nil {
		if !takeActivationChance() {
			fmt.Println("The application could not be activated by license and will shut down")
			os.Exit(2)
		}
	}

	// If there is an activation secret, check if it's correct
	if settings.Server.Activation.Secret != nil && settings.Server.Activation.InstallId != nil {
		if !checkActivation() {
			fmt.Println("This product is not activated")
			fmt.Println("The application could not be activated by license and will shut down")
			os.Exit(2)
		}
	} else {
		// Can't continue
		fmt.Println("There must be a secret and a installation ID in the config file to check the activation this product.")
		fmt.Println("The application could not be activated by license and will shut down")
		os.Exit(2)
	}
}

type TakeChanceActivation struct {
	LicenseCode string `json:"licenseCode"`
	Chance      string `json:"chance"`
	InstallId   string `json:"installId"`
}

// Change the secret by a secret code
func takeActivationChance() bool {
	// Generate a random installation ID for this server. This code gets generated by the client for every activation.
	takeActivationChance := TakeChanceActivation{
		LicenseCode: settings.Server.Activation.LicenseCode,
		Chance:      *settings.Server.Activation.Chance,
		InstallId:   uuid.New().String(),
	}
	data, _ := json.Marshal(takeActivationChance)
	resp, err := http.Post(CHANCE_URL, "application/json", bytes.NewBuffer(data))
	if err != nil {
		fmt.Println(err)
		return false
	}

	// Get the license secret. This code gets generated by the server for every activation.
	response, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		fmt.Println(err)
		return false
	}
	secret := string(response)
	if len(secret) == 30 {
		settings.Server.Activation.Chance = nil
		settings.Server.Activation.Secret = &secret
		settings.Server.Activation.InstallId = &takeActivationChance.InstallId
		ok := settings.setBackendSettings()

		if !ok {
			fmt.Println("Could not save the activation secret to the config file.")
		}

		return ok
	} else {
		fmt.Println("The server has refused the activation of the license. Check the chance code again.")
		return false
	}
}

type ServerActivation struct {
	LicenseCode string `json:"licenseCode"`
	Secret      string `json:"secret"`
	InstallId   string `json:"installId"`
}

type ServerActivationResult struct {
	Ok             bool  `json:"ok"`
	MaxConnections int16 `json:"maxConnections"`
}

func checkActivation() bool {
	a := ServerActivation{
		LicenseCode: settings.Server.Activation.LicenseCode,
		Secret:      *settings.Server.Activation.Secret,
		InstallId:   *settings.Server.Activation.InstallId,
	}
	data, _ := json.Marshal(a)
	resp, err := http.Post(ACTIVATE_URL, "application/json", bytes.NewBuffer(data))
	if err != nil {
		fmt.Println(err)
		return false
	}

	// Get the check
	response, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		fmt.Println(err)
		return false
	}
	var result ServerActivationResult
	json.Unmarshal(response, &result)

	if result.Ok { // Successfully activated
		setLicenseMaxConnectionsLimit(result.MaxConnections)
		return true
	} else {
		// The license code is incorrect or (probably) the license code has been used in another marketnet installation so the secret or install id has changed.
		// Remove the activation data from the settings and prevent the server from starting.
		settings.Server.Activation.Chance = nil
		settings.Server.Activation.Secret = nil
		settings.Server.Activation.InstallId = nil
		settings.setBackendSettings()
		return false
	}
}

// Changes done here must algo be done in the updateSettingsRecord function in settings.go.
func setLicenseMaxConnectionsLimit(maxConnections int16) {
	licenseMaxConnections = maxConnections
	s := getSettingsRecord()
	if s.MaxConnections == 0 {
		s.MaxConnections = int32(licenseMaxConnections)
	} else {
		s.MaxConnections = int32(math.Min(float64(s.MaxConnections), float64(licenseMaxConnections)))
	}
	s.updateSettingsRecord()
}
